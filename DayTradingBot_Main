// MetaT5Bot ////////////////////////////////////////////////////////////////////
// IchimokuBitcoinMT5_Robot -  Luke Jeffers - 2023 - All rights reserved      //
///////////////////////////////////////////////////////////////////////////////

/*

DISCLAIMER: Trading involves risk. You should carefully consider your investment objectives,
level of experience, and risk appetite before making a decision to invest in any financial product.
Trading may not be suitable for all investors. Past performance is not indicative of future results.
The contents of this trading robot should not be construed as financial advice, and it is provided for
informational purposes only.

By using this trading robot, you acknowledge that you understand the risks involved in trading, and you
agree that the use of this trading robot is at your own risk. You also agree that the owner of this trading
robot is not liable for any losses that you may incur as a result of using this robot.

Reverse engineering and redistribution of this trading robot, or any part thereof, is strictly prohibited.
You agree that all profits generated by this trading robot belong to you as the rightful user, investor, or
holder of the robot.

By using this trading robot, you agree to all the terms and conditions set forth in this disclaimer.
If you do not agree with any of these terms, please do not use this trading robot.

*/


// create an instance of ctrade
#include <Trade\trade.mqh>
CTrade trade;

bool userAlerted;
string tradeAction;
int tickTradeDuration;
bool tradeStarted;
int awaitEntry;
int waitTime;
int entryThreshold;
int tradeLevel;
int waitTradeTime;
int numOfTradesOpen;
bool inTradeBuy;
bool inTradeSell;
bool inTrade2;
int checkCycle;
bool counterTrade;
double maxAllowedDist;
double lastBalance;
MqlRates PriceInfo[];
double spanAverage;
double spanLow;
double spanHigh;
double maxRiskAmt;
double coolDownPeriod;
double trendingDuration;
bool isHedgeTradeSell;
bool isHedgeTradeBuy;
double spanWidth;
double acceptedSpanWidth;
string tradeStatus;
double interest;
double currentPrice;
double debt;
double buyPrice;
double sellPrice;
double mult;
double lastPL;
bool hedgeBuy;
bool hedgeSell;
bool pendingSellSet;
double priceRange;
double priceMovePercentage;
int numSidesTested;
input bool tradeEnabled = false;
input int positionCount = 1;
//input bool tradeReversals = false;
double reversalBuySL = 0;
double reversalSellSL = 0;
input double defaultLotSize = 0.01;
input double lotScalingOffset = 0.01;
double lotSize;
double maxTrendingDuration;
double tradingFrequency;
double lotSizeHedging;


double myTenkanSenValue;
double myChikouValue;
double priceRangeStep;

bool p1Set;
bool p2Set;
bool p3Set;
double p1;
double p2;
double p3;
double pStep;
string tradeBias;
bool biasSellSet;
bool biasBuySet;

double numIncreaseLots;
double lotStepLimit;
int freqDelay;
double profitCount;
double takeProfit;
double hedgeWait;
double hedgeWaitDuration;
bool canTrade;
double multStep;
double retestLimit;
double breakoutRange;
double rangeTestCount;
double maxRangeTest;
double consolidationLimit;
bool analysisComplete;
double maxDrawdown;
bool tradePrimed;
double primedPrice;
double maPrice;
int posCount;
bool buyPriceSet;
bool sellPriceSet;
bool startSetBuyPrice;
bool startSetSellPrice;
double ma1;
double ma2;
double maGradient;
double maDist;
double defaultMaxLoss;
double maxLoss;
double unrealisedProfit;
double realisedProfit;
bool seekingProfit;
double timeInTrade;
double defaultTrailingStop;
double trailingStop;
int waveCount;

int highestCandle, lowestCandle;
double high[], low[];
int data;
double fibOffset;
double openPrice;
bool fibLevelsSet;
double priceDeviation;
bool priceDataSet;
double oldOpenPrice;
double maxDeviation;
double Multiplier;
input double reversalScale = 2.0;
input int candleAnalysisCount;
double setupBuyPrice;
double setupSellPrice;
double assetScaling;
double buyStopPrice;
double sellStopPrice;
string currentSymbol;
double maxAtr;
double sl_b;
double sl_s;
int scaling;
bool tradeComplete;
double capturedATRValue;
static int ticketStack[];
int myMA;

/*
void OpenBuyOrder()
   {

   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);

   MqlTradeRequest myrequest;
   MqlTradeResult myresult;
   ZeroMemory(myrequest);


   myrequest.action=TRADE_ACTION_DEAL;
   myrequest.type=ORDER_TYPE_BUY;
   myrequest.symbol=_Symbol;
   myrequest.volume=0.03;
   myrequest.type_filling=ORDER_FILLING_FOK;
   myrequest.price=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   myrequest.tp=309;
   myrequest.sl=0;
   myrequest.deviation=50;
   OrderSend(myrequest,myresult);


   }
*/






//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int OnInit()
  {
   userAlerted = false;
   tradeAction = "null";
   tickTradeDuration = 0;
   tradeStarted = false;


   awaitEntry = 0;
   waitTime = 1;
   entryThreshold = 5;
   tradeLevel = 0;
   waitTradeTime = 0;
   numOfTradesOpen = 0;
   inTradeBuy = false;
   inTradeSell = false;
   inTrade2 = false;
   spanAverage = 0;
   spanLow = 0;
   spanHigh = 0;


   trendingDuration = 0;
   isHedgeTradeSell = false;
   isHedgeTradeBuy = false;
   spanWidth = 0;
   

   debt = 0;   
   
   retestLimit = 300;
   currentPrice = 0;
   buyPrice = 0;
   profitCount = 0;
   sellPrice = 0;
   lastPL = 0;
   hedgeBuy = false;
   hedgeSell = false;
   
   
   
   acceptedSpanWidth = 700;
   
   tradeStarted = false;
   pendingSellSet = false;
   numSidesTested = 0;
   lotStepLimit = 6;
   priceRangeStep = 0;
   canTrade = true;
   takeProfit = 30;
   breakoutRange = 0;
   maxRangeTest = 0;
   rangeTestCount = 0;
   
   consolidationLimit = 100;
   
   
   mult = 3;
   freqDelay = 99999999999999999999999999999999999;
   priceRange = 0.01;
   maxAllowedDist = 2;
   posCount = 1;
   defaultMaxLoss = 200;
   maxLoss = defaultMaxLoss;
   defaultTrailingStop = 1;
   trailingStop = defaultTrailingStop;
   buyPrice = 100000;
   sellPrice = 0;
   fibOffset = 0;
   maxDeviation = 500;
   //candleAnalysisCount = 110;
   assetScaling = 4; // USD/JPY  Symbol/Asset 
   maxAtr = 0;
   tradeComplete = false;
   
   
   currentSymbol = Symbol();
   
   interest = 5;
   lotSize = defaultLotSize;
   scaling = 1;
   Multiplier = 3;
   
   
   
   
   // In your OnInit() function:
   myMA = iMA(_Symbol, _Period, 8, 0, MODE_EMA, PRICE_CLOSE);
   PlotIndexSetInteger(0, PLOT_LINE_COLOR, clrWhite);    // Set MA line color to red
   PlotIndexSetInteger(0, PLOT_LINE_STYLE, STYLE_SOLID); // Set line style
   PlotIndexSetInteger(0, PLOT_LINE_WIDTH, 2);         // Set line width
   long chart_id = ChartID();
   ChartIndicatorAdd(chart_id, 0, myMA);
   


   return(INIT_SUCCEEDED);

  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {
  ArraySetAsSeries(high, true);
  ArraySetAsSeries(low, true);
  
  CopyHigh(_Symbol,_Period,0,candleAnalysisCount,high);
  CopyLow(_Symbol,_Period,0,candleAnalysisCount,low);
  
  highestCandle = ArrayMaximum(high,0,candleAnalysisCount);
  lowestCandle = ArrayMinimum(low,0,candleAnalysisCount);
  
  MqlRates priceInformation[];
  ArraySetAsSeries(priceInformation, true);
  
  
  data = CopyRates(Symbol(), Period(), 0, Bars(Symbol(),Period()),priceInformation);
  
  ObjectDelete(_Symbol,"Fibonacci");
  
  ObjectCreate
  (
  _Symbol,
  "Fibonacci",
  OBJ_FIBO,
  0,
  priceInformation[candleAnalysisCount].time,
  priceInformation[highestCandle].high,
  priceInformation[0].time,
  priceInformation[lowestCandle].low
  );
  
  datetime dateTime0 = ObjectGetInteger(0,"Fibonacci",OBJPROP_TIME, 0);
  double priceLevel100 = ObjectGetDouble(0,"Fibonacci",OBJPROP_PRICE, 0);
  datetime dateTime1 = ObjectGetInteger(0,"Fibonacci",OBJPROP_TIME,1);
  double priceLevel0 = ObjectGetDouble(0,"Fibonacci",OBJPROP_PRICE,1);
  double priceLevel50= ((priceLevel100 + priceLevel0)*0.5);
  
  



//// Adding time constraints if needed
//MqlDateTime current_time;
//TimeToStruct(TimeLocal(), current_time);
//int hour = current_time.hour;
//// Check for new day
//if (hour == 13)
//{
//canTrade = true;
//profitCount = 0;     
//}
//
//
//if (profitCount > takeProfit)
//{
//canTrade = false;
//}


//// Adding time constraints if needed
MqlDateTime current_time;
TimeToStruct(TimeLocal(), current_time);
int hour = current_time.hour;
//// Check for new day
if (hour > 8 && hour < 21)
{
   canTrade = true;
}
else
{
canTrade = false;
}


// set current price
   currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
   double PL = (Equity - Balance);
   
   
   
   
   
   


// we calculate the ask price
//double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK,_Digits);

// we calculate the bid price
//double Bid=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID,_Digits);

   


// array for ATR price data
double myAtrArray[];  

// Sort it from current candle to oldest candle
ArraySetAsSeries(PriceInfo, true);

// Calculate ATR with a period of 14
int myAtr = iATR(_Symbol, _Period, 14);

// sort the price data from the current candle downwards
ArraySetAsSeries(myAtrArray,true);

// defined ea, from current candle, for 3 candles, save in array
CopyBuffer(myAtr,0,0,3,myAtrArray);

// calculate the current indicator values
double myAtrValue=myAtrArray[0];

// the ma



// Then in your OnTick():
double myMaArray[];
ArraySetAsSeries(myMaArray, true);
CopyBuffer(myMA, 0, 0, 3, myMaArray);
double myMaValue = myMaArray[0];





// trade entry conditions #0000

double midLevel =(((priceLevel100 + priceLevel0)*0.5));
double midLevel2 =(midLevel + priceLevel100)* 0.5;
double midLevel3 =(midLevel + priceLevel0)* 0.5;
double level61 = ((midLevel + midLevel2)* 0.5) - fibOffset;
double level38 = ((midLevel + midLevel3)*0.5) + fibOffset;

double n = 2;

openPrice = iOpen(Symbol(), PERIOD_H1, 0);
color LineColorP = clrMagenta;
color LineColorP2 = clrAqua;
color LineColorP3 = clrRed;


priceDeviation = MathAbs(currentPrice - ((buyPrice + sellPrice)/2));

if(!tradeStarted && !priceDataSet && myAtrValue > maxAtr && canTrade)
{
if(currentPrice < priceLevel100  && myMaValue > priceLevel0 )
{
oldOpenPrice = openPrice;
setupBuyPrice = priceLevel100;
setupSellPrice = priceLevel0;
capturedATRValue = myAtrValue;
buyStopPrice = (priceLevel100 - (myAtrValue*reversalScale));
sellStopPrice = (priceLevel0 + (myAtrValue*reversalScale));
ObjectCreate(0,"setupBuyPrice",OBJ_HLINE,0,0,setupBuyPrice);
ObjectCreate(0,"setupSellPrice",OBJ_HLINE,0,0,setupSellPrice);
ObjectCreate(0,"buyStopPrice",OBJ_HLINE,0,0,buyStopPrice);
ObjectCreate(0,"sellStopPrice",OBJ_HLINE,0,0,sellStopPrice);

ObjectSetInteger(0, "setupBuyPrice", OBJPROP_COLOR, LineColorP);
ObjectSetInteger(0, "setupSellPrice", OBJPROP_COLOR, LineColorP);
ObjectSetInteger(0, "buyStopPrice", OBJPROP_COLOR, LineColorP2);
ObjectSetInteger(0, "sellStopPrice", OBJPROP_COLOR, LineColorP2);

/*
sl_b = setupBuyPrice + (myAtrValue * 1);
sl_s = setupSellPrice - (myAtrValue * 1);
ObjectCreate(0,"sl_b",OBJ_HLINE,0,0,sl_b);
ObjectCreate(0,"sl_s",OBJ_HLINE,0,0,sl_s);
ObjectSetInteger(0, "sl_b", OBJPROP_COLOR, LineColorP3);
ObjectSetInteger(0, "sl_s", OBJPROP_COLOR, LineColorP3);
*/



priceDataSet = true;
}
}

if(priceDataSet && !tradeStarted)
{

// up-side
if(tradeEnabled && currentPrice > buyStopPrice)
{
   buyPrice = setupBuyPrice;
   sellPrice = buyStopPrice;
    
   tradeStarted = true;
}

// down-side
if(tradeEnabled && currentPrice < sellStopPrice)
{
   buyPrice = sellStopPrice;
   sellPrice = setupSellPrice;
   
   tradeStarted = true;
}

}








//buyPrice = currentPrice + 50; 
//sellPrice = currentPrice - 50; 
//ObjectCreate(0,"buyPrice",OBJ_HLINE,0,0,buyPrice);
//ObjectCreate(0,"sellPrice",OBJ_HLINE,0,0,sellPrice);
   
    
////////////////////////////////////
// starting the trades
// Selling
   if(!hedgeSell && !tradeComplete && currentPrice < (sellPrice - breakoutRange) && tradeStarted && canTrade)
     {   
             

         numSidesTested++;
         printf("numsidesTested: " + numSidesTested);
         rangeTestCount++;
         numIncreaseLots++;
         lastPL-=PL;
        
         //trade.PositionClose(Symbol());
         
         
         for (int i = 0; i < ArraySize(ticketStack); i++)
         {
         trade.PositionClose(ticketStack[i],-1);
         }
         for (int i = 0; i < positionCount; i++)
         {
         trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         ulong tradeTicket = trade.ResultOrder();
         ArrayResize(ticketStack, ArraySize(ticketStack) + 1);
         ticketStack[ArraySize(ticketStack) - 1] = tradeTicket;
         }
         
         
         
         
         if(numSidesTested > 0 && numSidesTested % scaling == 0)
         {
         
         lotSize+=lotScalingOffset;         
         }
         
         
         
         
         
         hedgeBuy = false;
         hedgeSell = true;  
         tradeAction = "sell";
             
     }
// Buying
   if(!hedgeBuy && !tradeComplete && currentPrice > (buyPrice + breakoutRange) && tradeStarted && canTrade)
     {
         
         
         numSidesTested++;
         printf("numsidesTested: " + numSidesTested);
         rangeTestCount++;
         numIncreaseLots++;
         lastPL-=PL;
         
         //trade.PositionClose(Symbol());
         
         
         for (int i = 0; i < ArraySize(ticketStack); i++)
         {
         trade.PositionClose(ticketStack[i],-1);
         }
         for (int i = 0; i < positionCount; i++)
         {
         trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         ulong tradeTicket = trade.ResultOrder();
         ArrayResize(ticketStack, ArraySize(ticketStack) + 1);
         ticketStack[ArraySize(ticketStack) - 1] = tradeTicket;
         }
         
         
         
         if(numSidesTested > 0 && numSidesTested % scaling == 0 && lotSize < 1)
         {
         
         lotSize+=lotScalingOffset;
         }
         
         
         
         
         hedgeSell = false;
         hedgeBuy = true;
         tradeAction = "buy";
         
        
     }
 
     
     
     
//locking profit 
debt = MathAbs(lastPL);     
/*    
     
     // closing trades #3333
     if (PL > (debt + profitTarget))
     {
      tradePrimed = false;
      hedgeBuy = false;  
      hedgeSell = false;
      for (int i = 0; i < ArraySize(ticketStack); i++)
      {
      trade.PositionClose(ticketStack[i],-1);
      }     
      posCount = 1;
      lastPL=0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      rangeTestCount = 0;
      primedPrice = 1;
      maPrice = -1;
      buyPriceSet = false;
      sellPriceSet = false;
      seekingProfit = false;
      timeInTrade = 0;
      trailingStop = defaultTrailingStop;
      buyPrice = 100000;
      sellPrice = 0;
      tradeAction = "null";
      tradeComplete = true;
      priceDataSet = false;
      tradeStarted = false;
      }
      */
      
      /*
      // stop loss logic for reversals
      if (reversalBuySL > 0 && reversalSellSL > 0)
     {if (currentPrice > reversalBuySL || currentPrice < reversalSellSL){
      for (int i = 0; i < ArraySize(ticketStack); i++)
      {
      trade.PositionClose(ticketStack[i],-1);
      }
      }
      }
      */
      
      
      
      
      
      
      
      /*
      //cancelling trades
      if(priceDataSet){
      if(currentPrice > sl_b || currentPrice < sl_s){
      
      tradePrimed = false;
      hedgeBuy = false;  
      hedgeSell = false;
      for(int i=0; i < posCount; i++)
      {
         trade.PositionClose(Symbol());
      }
      posCount = 1;
      lastPL=0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      rangeTestCount = 0;
      primedPrice = 1;
      maPrice = -1;
      buyPriceSet = false;
      sellPriceSet = false;
      seekingProfit = false;
      timeInTrade = 0;
      trailingStop = defaultTrailingStop;
      buyPrice = 100000;
      sellPrice = 0;
      tradeAction = "null";
      priceDataSet = false;
      tradeStarted = false;
      }
      }
    */
    



     if(awaitEntry > 0)
     {
      awaitEntry--;
     }
     
     
     if(rangeTestCount > maxRangeTest)
     {
     maxRangeTest = rangeTestCount;
     }
     
     if (PL < maxDrawdown)
     {
     maxDrawdown = PL;
     }
     


  



////////////////////////////////////

//print values to screen
   string myString;
   string myString2;
   string myString3;

// Convert bool to string
   if(buyPriceSet)
     {
      myString = "true";
     }
   else
     {
      myString = "false";
     }

// Convert bool to string
   if(sellPriceSet)
     {
      myString2 = "true";
     }
   else
     {
      myString2 = "false";
     }

// Convert bool to string
   if(tradeStarted)
     {
      myString3 = "true";
     }
   else
     {
      myString3 = "false";
     }





   string text=
      "Balance  | "+DoubleToString(Balance,Digits()+1)+ "\n" +
      "P&L  | "+DoubleToString(PL,Digits()+1) + "\n"+
      "Debt  | "+DoubleToString(debt,Digits()+1) + "\n"+
      "Current  | "+DoubleToString(currentPrice,Digits()+1) + "\n"+
      "Buy price  | "+DoubleToString(buyPrice,Digits()+1) + "\n"+
      "Sell price  | "+DoubleToString(sellPrice,Digits()+1) + "\n"+
      "Wait  | "+DoubleToString(awaitEntry,Digits()+1) + "\n"+
      "Max chain  | "+DoubleToString(maxRangeTest,Digits()+1) + "\n"+
      "Max drawdown  | "+DoubleToString(maxDrawdown,Digits()+1) + "\n"+
      "Min Lots  | "+DoubleToString(defaultLotSize,Digits()+1) + "\n"+
      "Consolidation limit  | "+DoubleToString(consolidationLimit,Digits()+1) + "\n"+
      "ATR  | "+DoubleToString(myAtrValue,Digits()+1) + "\n"+
      "Buy price set | "+ myString + "\n"+
      "Sell price set | "+ myString2 + "\n"+
      "In trade | "+ myString3 + "\n"+
      "Price range  | "+DoubleToString(priceRange,Digits()+1) + "\n"+
      "Num sidesTested | "+IntegerToString(numSidesTested)+ "\n" +
      "price deviation | "+DoubleToString(priceDeviation);

      
      
      
      

   Comment(text);
   
   

}
  
//+------------------------------------------------------------------+MT5|Expert!40
