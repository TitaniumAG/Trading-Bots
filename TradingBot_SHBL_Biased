// MetaT5Bot ////////////////////////////////////////////////////////////////////
// IchimokuBitcoinMT5_Robot -  Luke Jeffers - 2023 - All rights reserved              //
///////////////////////////////////////////////////////////////////////////////

/*

DISCLAIMER: Trading involves risk. You should carefully consider your investment objectives,
level of experience, and risk appetite before making a decision to invest in any financial product.
Trading may not be suitable for all investors. Past performance is not indicative of future results.
The contents of this trading robot should not be construed as financial advice, and it is provided for
informational purposes only.

By using this trading robot, you acknowledge that you understand the risks involved in trading, and you
agree that the use of this trading robot is at your own risk. You also agree that the owner of this trading
robot is not liable for any losses that you may incur as a result of using this robot.

Reverse engineering and redistribution of this trading robot, or any part thereof, is strictly prohibited.
You agree that all profits generated by this trading robot belong to you as the rightful user, investor, or
holder of the robot.

By using this trading robot, you agree to all the terms and conditions set forth in this disclaimer.
If you do not agree with any of these terms, please do not use this trading robot.

*/


// create an instance of ctrade
#include <Trade\trade.mqh>

CTrade trade;

bool userAlerted;
string tradeAction;
int tickTradeDuration;
bool tradeStarted;
int awaitEntry;
int waitTime;
int entryThreshold;
int tradeLevel;
int waitTradeTime;
int numOfTradesOpen;
bool inTradeBuy;
bool inTradeSell;
bool inTrade2;
int checkCycle;
bool counterTrade;
double maxAllowedDist;
double lastBalance;
MqlRates PriceInfo[];
double spanAverage;
double spanLow;
double spanHigh;
double maxRiskAmt;
double coolDownPeriod;
double trendingDuration;
bool isHedgeTradeSell;
bool isHedgeTradeBuy;
double spanWidth;
double acceptedSpanWidth;
string tradeStatus;
double interest;
double currentPrice;
double debt;
double buyPrice;
double sellPrice;
double mult;
double lastPL;
bool hedgeBuy;
bool hedgeSell;
bool pendingSellSet;
double priceRange;
double priceMovePercentage;
int numSidesTested;
double defaultLotSize;
double lotSize;
double maxTrendingDuration;
double tradingFrequency;
double lotSizeHedging;
string tradingZone;


double priceRangeStep;

bool p1Set;
bool p2Set;
bool p3Set;
double p1;
double p2;
double p3;
double pStep;
string tradeBias;
bool biasSellSet;
bool biasBuySet;

double numIncreaseLots;
double lotStepLimit;
int freqDelay;
double profitCount;
double takeProfit;
double hedgeWait;
double hedgeWaitDuration;
bool canTrade;
double multStep;
double retestLimit;
double breakoutRange;
double rangeTestCount;
double maxRangeTest;
double consolidationLimit;
bool analysisComplete;
double maxDrawdown;
double priceDeviation;
double maxLoss;
double priceDataSet;
int flowControlIdx;


datetime currentBarTime = iTime(_Symbol, _Period, 0);
datetime lastBarTime = currentBarTime;
double lastPrice;
int tradeStepIdx;
int tradePositionCount;
string tradingBias;
double lastOpenPrice;
/*
void OpenBuyOrder()
   {

   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);

   MqlTradeRequest myrequest;
   MqlTradeResult myresult;
   ZeroMemory(myrequest);


   myrequest.action=TRADE_ACTION_DEAL;
   myrequest.type=ORDER_TYPE_BUY;
   myrequest.symbol=_Symbol;
   myrequest.volume=0.03;
   myrequest.type_filling=ORDER_FILLING_FOK;
   myrequest.price=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   myrequest.tp=309;
   myrequest.sl=0;
   myrequest.deviation=50;
   OrderSend(myrequest,myresult);


   }
*/






//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int OnInit()
  {
   userAlerted = false;
   tradeAction = "null";
   tickTradeDuration = 0;
   tradeStarted = false;


   awaitEntry = 0;
   waitTime = 1;
   entryThreshold = 5;
   tradeLevel = 0;
   waitTradeTime = 0;
   numOfTradesOpen = 0;
   inTradeBuy = false;
   inTradeSell = false;
   inTrade2 = false;
   spanAverage = 0;
   spanLow = 0;
   spanHigh = 0;


   trendingDuration = 0;
   isHedgeTradeSell = false;
   isHedgeTradeBuy = false;
   spanWidth = 0;
   

   debt = 0;

   
   retestLimit = 300;
   currentPrice = 0;
   buyPrice = 0;
   profitCount = 0;
   sellPrice = 0;
   lastPL = 0;
   hedgeBuy = false;
   hedgeSell = false;
   freqDelay = 500;
   acceptedSpanWidth = 3;
   tradeStarted = false;
   pendingSellSet = false;
   numSidesTested = 0;
   lotStepLimit = 5;
   priceRangeStep = 0;
   canTrade = true;
   takeProfit = 30;
   breakoutRange = 0;
   maxRangeTest = 0;
   rangeTestCount = 0;
   mult = 2;
   consolidationLimit = 100;
   maxAllowedDist = 200;
   priceRange = 500;
   
   defaultLotSize = 0.01;
   lotSize = defaultLotSize;   
   interest = 33;
   maxLoss = 300;
   tradingBias = "null";

   return(INIT_SUCCEEDED);

  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {
  

/*
//// Adding time constraints if needed
MqlDateTime current_time;
TimeToStruct(TimeLocal(), current_time);
int hour = current_time.hour;
//// Check for new day
if (hour > 13 && hour < 20)
{
canTrade = true;
}
else
{
canTrade = false;
}
*/
//
//
//if (profitCount > takeProfit)
//{
//canTrade = false;
//}


// Get the current server time
    datetime current_day = TimeCurrent();

   
// Create a structure to hold time information
    MqlDateTime time_struct;
    TimeToStruct(current_day, time_struct);

// Get the day of the week (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
    int day_of_week = time_struct.day_of_week;
    
string day_name;
    
    switch(day_of_week)
    {
        case 0: day_name = "Sunday"; break;
        case 1: day_name = "Monday"; break;
        case 2: day_name = "Tuesday"; break;
        case 3: day_name = "Wednesday"; break;
        case 4: day_name = "Thursday"; break;
        case 5: day_name = "Friday"; break;
        case 6: day_name = "Saturday"; break;
        default: day_name = "Unknown";
    }
    day_name = "Monday";
    //Print(day_name);
//+------------------------------------------------------------------+



MqlDateTime current_time;
TimeToStruct(TimeLocal(), current_time);
int hour = current_time.hour;
//// Check for new day
if(!canTrade && hour == 0)
{
canTrade = true;
}

// set current price
   currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
   double PL = (Equity - Balance);


// we calculate the ask price
//double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK,_Digits);

// we calculate the bid price
//double Bid=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID,_Digits);


// create array for the price data
   double myRSIArray[];
   double myCCIArray[];
   double macd_array[];
   double macd_buffer[];
   double signal_buffer[];
   double myMaArray[];
   int ma_fast_period = 12;
   int ma_slow_period = 26;
   int ma_signal_period = 9;
   



// Sort it from current candle to oldest candle
   //ArraySetAsSeries(PriceInfo, true);
   
   

   int myRSIDefinition=iRSI(_Symbol, _Period,14,PRICE_CLOSE);
   int myCCIDefinition=iCCI(_Symbol, _Period,14,PRICE_CLOSE);
   
   int myMA=iMA(_Symbol,_Period,8,0,MODE_EMA,PRICE_CLOSE);



// sort the price data from the current candle downwards
   ArraySetAsSeries(myRSIArray,true);
   ArraySetAsSeries(myCCIArray,true);

   ArraySetAsSeries(myMaArray,true);





// defined ea, from current candle, for 3 candles, save in array
   CopyBuffer(myMA,0,0,3,myMaArray);
   CopyBuffer(myRSIDefinition,0,0,3,myRSIArray);
   CopyBuffer(myCCIDefinition,0,0,3,myCCIArray);

   


   
   
   // Define the y-values (doubles)
    double pointA = myMaArray[0];
    double pointB = myMaArray[2];

    // Define the x-values (assuming equal spacing)
    double x1 = 1, x2 = 3;

    // Calculate gradients between the points
    double gradientAB = MathAbs((pointA - pointB) / (x2 - x1)); // Gradient between A and B
   

    // Output the gradients
    //PrintFormat("Gradient between A and B: %.6f", gradientAB);
   


// calculate the current rsi & cci values
   double myMaValue=myMaArray[0];
   double myRSIValue=NormalizeDouble(myRSIArray[0],2);
   double myCCIValue=NormalizeDouble(myCCIArray[0],2);

   
   
   double mySpanAArray[];
   double mySpanBArray[];
   double myTenkanSenArray[];
   double myChikouArray[];
   int myIchimokuDefinition=iIchimoku(_Symbol, _Period,9,26,52);
   ArraySetAsSeries(mySpanAArray,true);
   ArraySetAsSeries(mySpanBArray,true);
   ArraySetAsSeries(myTenkanSenArray,true);
   ArraySetAsSeries(myChikouArray,true);
   CopyBuffer(myIchimokuDefinition,2,0,3,mySpanAArray);
   CopyBuffer(myIchimokuDefinition,3,0,3,mySpanBArray);
   CopyBuffer(myIchimokuDefinition,0,0,3,myTenkanSenArray);
   CopyBuffer(myIchimokuDefinition,1,0,4,myChikouArray);
   double mySpanAValue=mySpanAArray[0];
   double mySpanBValue=mySpanBArray[0];
   double myTenkanSenValue = myTenkanSenArray[0];
   double myChikouValue = myChikouArray[0];
   
   
   myTenkanSenValue=myTenkanSenArray[0];
   myChikouValue=myChikouArray[0];
  
  
  double maRange = MathAbs(currentPrice - myMaValue);


   
   
//macd_handle = iMA(_Symbol, 0, ma_fast_period, 0, MODE_EMA, PRICE_CLOSE) - iMA(_Symbol, 0, ma_slow_period, 0, MODE_EMA, PRICE_CLOSE);



   spanAverage = (mySpanAValue + mySpanBValue)/2;
   spanWidth = MathAbs(mySpanAValue - mySpanBValue);
   spanHigh = (spanAverage + maxAllowedDist);
   spanLow = (spanAverage - maxAllowedDist);
   
   
   //ObjectCreate(0,"My Line",OBJ_HLINE,0,0,spanAverage);
   
   double cloudDist = MathAbs(currentPrice - spanAverage);
   


   double n = 2;
   double m = 1000;


// Initial Buy trade; oversold conditions where sentiment is to buy up
//if (myRSIValue < 31 && myCCIValue < -100)
   //if(myRSIValue < 31 && myCCIValue < - 100 && currentPrice < spanLow && awaitEntry < 1 && spanWidth > acceptedSpanWidth)
   if (canTrade && cloudDist > maxAllowedDist && !priceDataSet && myRSIValue < 30 && myCCIValue < -100 && day_name != "Friday" && day_name != "Saturday" && day_name != "Sunday" && day_name != "Thursday" && awaitEntry < 1)
     {
     if(tradeStarted)
        {
     tradeAction = "buy";
     rangeTestCount = 0; 
     buyPrice = currentPrice - m;
     sellPrice = currentPrice - m*n;
     //trade.Buy(defaultLotSize,NULL,Ask,(0),(0),"Bot executed trade");
     ObjectCreate(0,"My Line",OBJ_HLINE,0,0,buyPrice);
     ObjectCreate(0,"My Line2",OBJ_HLINE,0,0,sellPrice);
     priceDataSet = true;
     // Buy hedge prevention because we are already selling! Important!
     }
      
     }
///////////////


// Initial Sell trade; overbought conditions where sentiment is to sell down
//if (myRSIValue < 31 && myCCIValue < -100)
    if (canTrade && cloudDist > maxAllowedDist && !priceDataSet && myRSIValue > 70 && myCCIValue > 100 && day_name != "Friday" && day_name != "Saturday" && day_name != "Sunday" && day_name != "Thursday" && awaitEntry < 1)
     {
      if(tradeStarted)
        {
         tradeAction = "sell";
         rangeTestCount = 0; 
         buyPrice = currentPrice + m*n;
         sellPrice = currentPrice + m;
         //trade.Sell(defaultLotSize,NULL,Ask,(0),(0),"Bot executed trade");
         ObjectCreate(0,"My Line",OBJ_HLINE,0,0,buyPrice);
         ObjectCreate(0,"My Line2",OBJ_HLINE,0,0,sellPrice);
         priceDataSet = true;
         // Sell hedge prevention because we are already selling! Important!
        }
     }
///////////////


// priming trades
   if(myMaValue > sellPrice && currentPrice < buyPrice)
   {
   //tradeStarted = true;
   }


   
   priceDeviation = MathAbs(((buyPrice + sellPrice)/2) - myMaValue);
   

   
   if(!tradeStarted)
   {
      if (priceDeviation > 2000 && priceDataSet && numSidesTested == 0)
      {
      tradeStarted = false;
      hedgeBuy = false;
      hedgeSell = false;
      trade.PositionClose(Symbol());
      lastPL = 0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      profitCount = profitCount + interest;
      priceDataSet = false;
      printf("Deviation caught");
      }
   }


      currentBarTime = iTime(_Symbol, _Period, 0);
         
         if (currentBarTime != lastBarTime)
          {
              // A new candle has formed, so do something
              tradeStepIdx++; 
              Print("flow control: " + flowControlIdx);
              //Print("New candle closed!");
              
              
              if(tradeStepIdx > 1)
              {
               if (currentPrice < lastPrice && myRSIValue < 35)
               {
               flowControlIdx++;
               if(tradingBias == "null")
               {
               tradingBias = "buy";
               }
               if(tradingBias == "buy")
               {
               if(flowControlIdx < 2){
               lastOpenPrice = currentPrice;
               trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
               tradePositionCount++;
               }
               if(flowControlIdx > 2){
               if(currentPrice < lastOpenPrice){
               lastOpenPrice = currentPrice;
               trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
               tradePositionCount++;
               }
               }
               }
               }
               
               if (currentPrice > lastPrice && myRSIValue > 65)
               {
               flowControlIdx++;
               if(tradingBias == "null")
               {
               tradingBias = "sell";
               }  
               if(tradingBias == "sell")
               {
               if(flowControlIdx < 2){
               lastOpenPrice = currentPrice;
               trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
               tradePositionCount++;
               }
               if(flowControlIdx > 2){
               if(currentPrice > lastOpenPrice){
               lastOpenPrice = currentPrice;
               trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
               tradePositionCount++;
               }
               }
               }             
               }
               
              }
              
                           
              // Update the lastBarTime to the current bar's time
              lastPrice = currentPrice;
              lastBarTime = currentBarTime;
          }





////////////////////////////////////
// starting the hedge trades

   if(!hedgeSell && currentPrice < (sellPrice) && tradeStarted)
     {     
       
         numSidesTested++;
         rangeTestCount++;
         numIncreaseLots++;
         
        
         lastPL = lastPL + PL;
         trade.PositionClose(Symbol());
         
         
         //trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
      
         
          if(numSidesTested < lotStepLimit)
         { 
         lotSize  = lotSize * mult;    
         } 
                  
                  
     
            
         buyPrice = buyPrice + priceRangeStep;
         hedgeWait = hedgeWaitDuration;         
         hedgeBuy = false;
         hedgeSell = true;        
     }
   if(!hedgeBuy && currentPrice > (buyPrice) && tradeStarted)
     {
      
         numSidesTested++;
         rangeTestCount++;
         numIncreaseLots++;
         
         
         lastPL = lastPL + PL;
         trade.PositionClose(Symbol());
         
         printf("hello world");
         //trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         
         
         
         if(numSidesTested < lotStepLimit)
         { 
         lotSize  = lotSize * mult; 
         }
         
                  
         
                 
         sellPrice = sellPrice - priceRangeStep;
         hedgeWait = hedgeWaitDuration;         
         hedgeSell = false;
         hedgeBuy = true;
        
     }
     
     
     
     
     
    
     
     

// locking profit
   debt = MathAbs(lastPL);
  
   
   if (PL > interest) //(debt + interest)
     {
      tradeStepIdx = 0;
      flowControlIdx = 0;
      priceDataSet = false;
      priceDeviation = 0;
      tradeStarted = false;
      hedgeBuy = false;
      hedgeSell = false;
      for(int i=0; i<tradePositionCount; i++)
      {
      trade.PositionClose(Symbol());
      }
      tradePositionCount = 0;
      tradingBias = "null";      
      buyPrice = 0;
      sellPrice = 0;
      lastPL = 0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      profitCount = profitCount + interest;
           
     }
     
// stop loss
   debt = MathAbs(lastPL);
  
   
   if (tradePositionCount > 10 && PL > -20) //(debt + interest)
     {
      tradeStepIdx = 0;
      flowControlIdx = 0;
      priceDataSet = false;
      priceDeviation = 0;
      tradeStarted = false;
      hedgeBuy = false;
      hedgeSell = false;
      for(int i=0; i<tradePositionCount; i++)
      {
      trade.PositionClose(Symbol());
      }
      tradePositionCount = 0;
      tradingBias = "null";      
      buyPrice = 0;
      sellPrice = 0;
      lastPL = 0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      profitCount = profitCount + interest;
           
     }
     
     /*
     if(day_name == "Thursday" || day_name == "Friday" || day_name == "Saturday" || day_name == "Sunday")
     {
      priceDataSet = false;
      priceDeviation = 0;
      tradeStarted = false;
      hedgeBuy = false;
      hedgeSell = false;
      trade.PositionClose(Symbol());
      buyPrice = 0;
      sellPrice = 0;
      lastPL = 0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      profitCount = profitCount + interest;
     }
     */
/*
     if (debt > maxLoss) //(debt + interest)
     {
      canTrade = false;
      priceDataSet = false;
      priceDeviation = 0;
      tradeStarted = false;
      hedgeBuy = false;
      hedgeSell = false;
      trade.PositionClose(Symbol());
      buyPrice = 0;
      sellPrice = 0;
      lastPL = 0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      profitCount = profitCount + interest;
           
     }
     */
    



     if(awaitEntry > 0)
     {
      awaitEntry--;
     }
     
     
     if(rangeTestCount > maxRangeTest)
     {
     maxRangeTest = rangeTestCount;
     }
     
     if (PL < maxDrawdown)
     {
     maxDrawdown = PL;
     }
     


  



////////////////////////////////////

//print values to screen
   string myString;

// Convert bool to string
   if(priceDataSet)
     {
      myString = "true";
     }
   else
     {
      myString = "false";
     }




   string text=
      "Balance  | "+DoubleToString(Balance,Digits()+1)+ "\n"+
      "Debt  | "+DoubleToString(debt,Digits()+1) + "\n"+
      "P&L  | "+DoubleToString(PL,Digits()+1) + "\n"+
      "Current  | "+DoubleToString(currentPrice,Digits()+1) + "\n"+
      "Buy price  | "+DoubleToString(buyPrice,Digits()+1) + "\n"+
      "Sell price  | "+DoubleToString(sellPrice,Digits()+1) + "\n"+
      "In trade  | "+ myString + "\n"+
      "RSI  | "+DoubleToString(myRSIValue,Digits()+1) + "\n"+
      "CCI  | "+DoubleToString(myCCIValue,Digits()+1) + "\n"+
      "Wait  | "+DoubleToString(awaitEntry,Digits()+1) + "\n"+
      "Max chain  | "+DoubleToString(maxRangeTest,Digits()+1) + "\n"+
      "Max drawdown  | "+DoubleToString(maxDrawdown,Digits()+1) + "\n"+
      "Consolidation limit  | "+DoubleToString(consolidationLimit,Digits()+1) + "\n"+
      "Max chain  | "+DoubleToString(rangeTestCount,Digits()+1) + "\n"+
      "Price deviation  | "+DoubleToString(priceDeviation,Digits()+1) + "\n"+
      "MA range  | "+DoubleToString(maRange,Digits()+1) + "\n"+
      "Cloud distance | "+DoubleToString(cloudDist,Digits()+1) + "\n"+
      "Day name  | "+ day_name;

   Comment(text);


  }
//+------------------------------------------------------------------+
