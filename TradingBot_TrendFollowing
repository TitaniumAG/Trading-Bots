// MetaT5Bot ////////////////////////////////////////////////////////////////////
// IchimokuBitcoinMT5_Robot -  Luke Jeffers - 2023 - All rights reserved      //
///////////////////////////////////////////////////////////////////////////////

/*

DISCLAIMER: Trading involves risk. You should carefully consider your investment objectives,
level of experience, and risk appetite before making a decision to invest in any financial product.
Trading may not be suitable for all investors. Past performance is not indicative of future results.
The contents of this trading robot should not be construed as financial advice, and it is provided for
informational purposes only.

By using this trading robot, you acknowledge that you understand the risks involved in trading, and you
agree that the use of this trading robot is at your own risk. You also agree that the owner of this trading
robot is not liable for any losses that you may incur as a result of using this robot.

Reverse engineering and redistribution of this trading robot, or any part thereof, is strictly prohibited.
You agree that all profits generated by this trading robot belong to you as the rightful user, investor, or
holder of the robot.

By using this trading robot, you agree to all the terms and conditions set forth in this disclaimer.
If you do not agree with any of these terms, please do not use this trading robot.

*/


// create an instance of ctrade
#include <Trade\trade.mqh>
CTrade trade;

bool userAlerted;
string tradeAction;
int tickTradeDuration;
bool tradeStarted;
int awaitEntry;
int waitTime;
int entryThreshold;
int tradeLevel;
int waitTradeTime;
int numOfTradesOpen;
bool inTradeBuy;
bool inTradeSell;
bool inTrade2;
int checkCycle;
bool counterTrade;
double maxAllowedDist;
double lastBalance;
MqlRates PriceInfo[];
double spanAverage;
double spanLow;
double spanHigh;
double maxRiskAmt;
double coolDownPeriod;
double trendingDuration;
bool isHedgeTradeSell;
bool isHedgeTradeBuy;
double spanWidth;
double acceptedSpanWidth;
string tradeStatus;
double interest;
double currentPrice;
double debt;
double buyPrice;
double sellPrice;
double mult;
double lastPL;
bool hedgeBuy;
bool hedgeSell;
bool pendingSellSet;
double priceRange;
double priceMovePercentage;
int numSidesTested;
input double profitTarget;
input int positionCount;
input double defaultLotSize;
input double lotScalingOffset = 2;
double lotSize;
double maxTrendingDuration;
double tradingFrequency;
double lotSizeHedging;


double myTenkanSenValue;
double myChikouValue;
double priceRangeStep;

bool p1Set;
bool p2Set;
bool p3Set;
double p1;
double p2;
double p3;
double pStep;
string tradeBias;
bool biasSellSet;
bool biasBuySet;

double numIncreaseLots;
double lotStepLimit;
int freqDelay;
double profitCount;
double takeProfit;
double hedgeWait;
double hedgeWaitDuration;
bool canTrade;
double multStep;
double retestLimit;
double breakoutRange;
double rangeTestCount;
double maxRangeTest;
double consolidationLimit;
bool analysisComplete;
double maxDrawdown;
bool tradePrimed;
double primedPrice;
double maPrice;
int posCount;
bool buyPriceSet;
bool sellPriceSet;
bool startSetBuyPrice;
bool startSetSellPrice;
double ma1;
double ma2;
double maGradient;
double maDist;
double defaultMaxLoss;
double maxLoss;
double unrealisedProfit;
double realisedProfit;
bool seekingProfit;
double timeInTrade;
double defaultTrailingStop;
double trailingStop;
int waveCount;

int highestCandle, lowestCandle;
double high[], low[];
int data;
double fibOffset;
double openPrice;
bool fibLevelsSet;
double priceDeviation;
bool priceDataSet;
double oldOpenPrice;
double maxDeviation;
double Multiplier;
input double reversalScale;
input int candleAnalysisCount;
double setupBuyPrice;
double setupSellPrice;
double assetScaling;
double buyStopPrice;
double sellStopPrice;
string currentSymbol;
double maxAtr;
double sl_b;
double sl_s;
int scaling;
bool tradeComplete;
bool lossComplete;
double capturedATRValue;
static int ticketStack[];
bool analysing;
double profitTargetShadow;

datetime currentBarTime = iTime(_Symbol, _Period, 0);
datetime lastBarTime = currentBarTime;
double lastPrice;
int tradeStepIdx;
int tradePositionCount;
string tradingBias;
double priceStack[];
double priceStackOpen[];
double priceStackClose[];
double weeklyPriceStack[];
double weeklyPriceStackOpen[];
double weeklyPriceStackClose[];
int candleCombo;
double rangeLimit;
int bullishPoints;
int bearishPoints;
bool tradeActive;
bool botPrimed;
double finalPriceLevel;
bool longPosition;
bool shortPosition;
double crossoverRange = 100;
string maStatus = "null";
bool crossUpReset;
bool crossDownReset;
bool tradeDone;


/*
void OpenBuyOrder()
   {

   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);

   MqlTradeRequest myrequest;
   MqlTradeResult myresult;
   ZeroMemory(myrequest);


   myrequest.action=TRADE_ACTION_DEAL;
   myrequest.type=ORDER_TYPE_BUY;
   myrequest.symbol=_Symbol;
   myrequest.volume=0.03;
   myrequest.type_filling=ORDER_FILLING_FOK;
   myrequest.price=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   myrequest.tp=309;
   myrequest.sl=0;
   myrequest.deviation=50;
   OrderSend(myrequest,myresult);


   }
*/






//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int OnInit()
  {
   userAlerted = false;
   tradeAction = "null";
   tickTradeDuration = 0;
   tradeStarted = false;


   awaitEntry = 0;
   waitTime = 1;
   entryThreshold = 5;
   tradeLevel = 0;
   waitTradeTime = 0;
   numOfTradesOpen = 0;
   inTradeBuy = false;
   inTradeSell = false;
   inTrade2 = false;
   spanAverage = 0;
   spanLow = 0;
   spanHigh = 0;


   trendingDuration = 0;
   isHedgeTradeSell = false;
   isHedgeTradeBuy = false;
   spanWidth = 0;
   

   debt = 0;   
   
   retestLimit = 300;
   currentPrice = 0;
   buyPrice = 0;
   profitCount = 0;
   sellPrice = 0;
   lastPL = 0;
   hedgeBuy = false;
   hedgeSell = false;
   
   
   
   acceptedSpanWidth = 700;
   
   tradeStarted = false;
   pendingSellSet = false;
   numSidesTested = 0;
   lotStepLimit = 6;
   priceRangeStep = 0;
   canTrade = true;
   takeProfit = 30;
   breakoutRange = 0;
   maxRangeTest = 0;
   rangeTestCount = 0;
   
   consolidationLimit = 100;
   
   
   mult = 3;
   freqDelay = 99999999999999999999999999999999999;
   priceRange = 0.01;
   maxAllowedDist = 2;
   posCount = 1;
   defaultMaxLoss = 200;
   maxLoss = defaultMaxLoss;
   defaultTrailingStop = 1;
   trailingStop = defaultTrailingStop;
   buyPrice = 100000;
   sellPrice = 0;
   fibOffset = 0;
   maxDeviation = 500;
   //candleAnalysisCount = 110;
   assetScaling = 4; // USD/JPY  Symbol/Asset 
   maxAtr = 0;
   tradeComplete = false;
   lossComplete = false;
   
   
   currentSymbol = Symbol();
   
   interest = 5;
   lotSize = defaultLotSize;
   scaling = 2;
   Multiplier = 3;
   analysing = false;
   profitTargetShadow = profitTarget;
   tradingBias = "null";


   return(INIT_SUCCEEDED);

  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {
  ArraySetAsSeries(high, true);
  ArraySetAsSeries(low, true);
  
  CopyHigh(_Symbol,_Period,0,candleAnalysisCount,high);
  CopyLow(_Symbol,_Period,0,candleAnalysisCount,low);
  
  highestCandle = ArrayMaximum(high,0,candleAnalysisCount);
  lowestCandle = ArrayMinimum(low,0,candleAnalysisCount);
  
  MqlRates priceInformation[];
  ArraySetAsSeries(priceInformation, true);
  
  
  data = CopyRates(Symbol(), Period(), 0, Bars(Symbol(),Period()),priceInformation);
  
  ObjectDelete(_Symbol,"Fibonacci");
  
  ObjectCreate
  (
  _Symbol,
  "Fibonacci",
  OBJ_FIBO,
  0,
  priceInformation[candleAnalysisCount].time,
  priceInformation[highestCandle].high,
  priceInformation[0].time,
  priceInformation[lowestCandle].low
  );
  
  datetime dateTime0 = ObjectGetInteger(0,"Fibonacci",OBJPROP_TIME, 0);
  double priceLevel100 = ObjectGetDouble(0,"Fibonacci",OBJPROP_PRICE, 0);
  datetime dateTime1 = ObjectGetInteger(0,"Fibonacci",OBJPROP_TIME,1);
  double priceLevel0 = ObjectGetDouble(0,"Fibonacci",OBJPROP_PRICE,1);
  double priceLevel50= ((priceLevel100 + priceLevel0)*0.5);
  int myMA=iMA(_Symbol,_Period,6,0,MODE_EMA,PRICE_CLOSE);
  double myMaArray[];
  ArraySetAsSeries(myMaArray,true);
  CopyBuffer(myMA,0,0,3,myMaArray);
  double myMaValue=myMaArray[0];
  
  int myMA2=iMA(_Symbol,_Period,26,0,MODE_SMA,PRICE_CLOSE);
  double myMaArray2[];
  ArraySetAsSeries(myMaArray2,true);
  CopyBuffer(myMA2,0,0,3,myMaArray2);
  double myMaValue2=myMaArray2[0];
  
  int myMA3=iMA(_Symbol,_Period,50,0,MODE_SMA,PRICE_CLOSE);
  double myMaArray3[];
  ArraySetAsSeries(myMaArray3,true);
  CopyBuffer(myMA3,0,0,3,myMaArray3);
  double myMaValue3=myMaArray3[0];
  
  double maRange = MathAbs(myMaValue - myMaValue2);
  



//// Adding time constraints if needed
//MqlDateTime current_time;
//TimeToStruct(TimeLocal(), current_time);
//int hour = current_time.hour;
//// Check for new day
//if (hour == 13)
//{
//canTrade = true;
//profitCount = 0;     
//}
//
//
//if (profitCount > takeProfit)
//{
//canTrade = false;
//}




MqlDateTime current_time;
TimeToStruct(TimeLocal(), current_time);
int hour = current_time.hour;
//// Check for new day
if (hour == 00)
{
canTrade = true;
profitCount = 0;     
}
//

// set current price
   currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
   double PL = (Equity - Balance);
   
   
   
   
   
   


// we calculate the ask price
//double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK,_Digits);

// we calculate the bid price
//double Bid=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID,_Digits);

   


// array for ATR price data
double myAtrArray[];  

// Sort it from current candle to oldest candle
ArraySetAsSeries(PriceInfo, true);

// Calculate ATR with a period of 14
int myAtr = iATR(_Symbol, _Period, 14);

// sort the price data from the current candle downwards
ArraySetAsSeries(myAtrArray,true);

// defined ea, from current candle, for 3 candles, save in array
CopyBuffer(myAtr,0,0,3,myAtrArray);

// calculate the current indicator values
double myAtrValue=myAtrArray[0];



// trade entry conditions #0000

double midLevel =(((priceLevel100 + priceLevel0)*0.5));
double midLevel2 =(midLevel + priceLevel100)* 0.5;
double midLevel3 =(midLevel + priceLevel0)* 0.5;
double level61 = ((midLevel + midLevel2)* 0.5) - fibOffset;
double level38 = ((midLevel + midLevel3)*0.5) + fibOffset;

openPrice = iOpen(Symbol(), PERIOD_H1, 0);





color LineColorP = clrMagenta;
color LineColorP2 = clrAqua;
color LineColorP3 = clrRed;



priceRange = (buyPrice - sellPrice);
priceDeviation = MathAbs(currentPrice - ((buyPrice + sellPrice)/2));

if(!tradeStarted && !priceDataSet && awaitEntry < 1 && myAtrValue > maxAtr)
{
if(currentPrice < priceLevel100  && currentPrice > priceLevel0 )
{
oldOpenPrice = openPrice;
setupBuyPrice = priceLevel100;
setupSellPrice = priceLevel0;
capturedATRValue = myAtrValue;
buyStopPrice = (priceLevel100 - (myAtrValue*reversalScale));
sellStopPrice = (priceLevel0 + (myAtrValue*reversalScale));
ObjectCreate(0,"setupBuyPrice",OBJ_HLINE,0,0,setupBuyPrice);
ObjectCreate(0,"setupSellPrice",OBJ_HLINE,0,0,setupSellPrice);
ObjectCreate(0,"buyStopPrice",OBJ_HLINE,0,0,buyStopPrice);
ObjectCreate(0,"sellStopPrice",OBJ_HLINE,0,0,sellStopPrice);

ObjectSetInteger(0, "setupBuyPrice", OBJPROP_COLOR, LineColorP);
ObjectSetInteger(0, "setupSellPrice", OBJPROP_COLOR, LineColorP);
ObjectSetInteger(0, "buyStopPrice", OBJPROP_COLOR, LineColorP2);
ObjectSetInteger(0, "sellStopPrice", OBJPROP_COLOR, LineColorP2);

/*
sl_b = setupBuyPrice + (myAtrValue * 1);
sl_s = setupSellPrice - (myAtrValue * 1);
ObjectCreate(0,"sl_b",OBJ_HLINE,0,0,sl_b);
ObjectCreate(0,"sl_s",OBJ_HLINE,0,0,sl_s);
ObjectSetInteger(0, "sl_b", OBJPROP_COLOR, LineColorP3);
ObjectSetInteger(0, "sl_s", OBJPROP_COLOR, LineColorP3);
*/


if (!analysing)
{
priceDataSet = true;
}

}
}

if(priceDataSet && !tradeStarted && awaitEntry < 1)
{

// continuous price updates so we can edit on the fly
buyStopPrice = (setupBuyPrice - (capturedATRValue*reversalScale));
sellStopPrice = (setupSellPrice + (capturedATRValue*reversalScale));
ObjectCreate(0,"setupBuyPrice",OBJ_HLINE,0,0,setupBuyPrice);
ObjectCreate(0,"setupSellPrice",OBJ_HLINE,0,0,setupSellPrice);
ObjectCreate(0,"buyStopPrice",OBJ_HLINE,0,0,buyStopPrice);
ObjectCreate(0,"sellStopPrice",OBJ_HLINE,0,0,sellStopPrice);

if(!analysing && myMaValue > buyStopPrice)
{
   buyPrice = setupBuyPrice;
   sellPrice = buyStopPrice;
   tradeStarted = true;
}
if(!analysing && myMaValue < sellStopPrice)
{
   buyPrice = sellStopPrice;
   sellPrice = setupSellPrice;
   tradeStarted = true;
}

}








//buyPrice = currentPrice + 50; 
//sellPrice = currentPrice - 50; 
//ObjectCreate(0,"buyPrice",OBJ_HLINE,0,0,buyPrice);
//ObjectCreate(0,"sellPrice",OBJ_HLINE,0,0,sellPrice);
   


    
////////////////////////////////////
// starting the trades
// Selling
   if(tradeStarted && !hedgeSell && !tradeComplete && myMaValue < myMaValue2 && maRange > crossoverRange)
     {   
             

         numSidesTested++;
         rangeTestCount++;
         numIncreaseLots++;
         //lastPL-=PL;
        
         for(int i = 0; i < tradePositionCount; i++)
         {
         //trade.PositionClose(Symbol()); 
         }
         for(int i = 0; i < positionCount; i++)
         {
         //trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         }
         
         /* specific close only
         for (int i = 0; i < ArraySize(ticketStack); i++)
         {
         trade.PositionClose(ticketStack[i],-1);
         }
         trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         ulong tradeTicket = trade.ResultOrder();
         ArrayResize(ticketStack, ArraySize(ticketStack) + 1);
         ticketStack[ArraySize(ticketStack) - 1] = tradeTicket;
         */   
         //lotSize*=lotScalingOffset;
         
         
         hedgeBuy = false;
         hedgeSell = true;  
         tradeAction = "sell";
             
     }
// Buying
   if(tradeStarted && !hedgeBuy && !tradeComplete && myMaValue > myMaValue2 && maRange > crossoverRange)
     {
         
         
         numSidesTested++;
         rangeTestCount++;
         numIncreaseLots++;
         //lastPL-=PL;
         
         for(int i = 0; i < tradePositionCount; i++)
         {
         //trade.PositionClose(Symbol()); 
         }
         for(int i = 0; i < positionCount; i++)
         {
         //trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         }
         
         /* specific close only
         for (int i = 0; i < ArraySize(ticketStack); i++)
         {
         trade.PositionClose(ticketStack[i],-1);
         }
         trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
         ulong tradeTicket = trade.ResultOrder();
         ArrayResize(ticketStack, ArraySize(ticketStack) + 1);
         ticketStack[ArraySize(ticketStack) - 1] = tradeTicket;
         */
         
         //lotSize*=lotScalingOffset;
         
         
         
         
         hedgeSell = false;
         hedgeBuy = true;
         tradeAction = "buy";
         
        
     }
     
     // above reset
      if(myMaValue > myMaValue3 && myMaValue2 > myMaValue3){
      if(myMaValue < myMaValue2){
      crossUpReset = true;
      crossDownReset = false;
      maStatus = "null";
      }
      }
      // above
      if(crossUpReset && myMaValue > myMaValue3 && myMaValue2 > myMaValue3){
      if(myMaValue > myMaValue2 && maRange > 10){
      tradeDone = false;
      maStatus = "crossAbove";
      }
      }
      
      
      
      // below reset
      if(myMaValue < myMaValue3 && myMaValue2 < myMaValue3){
      if(myMaValue > myMaValue2 && maRange > 10){
      crossDownReset = true;
      crossUpReset = false;
      maStatus = "null";
      }
      }
      // below
      if(crossDownReset && myMaValue < myMaValue3 && myMaValue2 < myMaValue3){
      if(myMaValue < myMaValue2){
      tradeDone = false;
      maStatus = "crossBelow";
      }
      }
     
     Print(maStatus);
     
     // candle expiry
       lastBarTime = currentBarTime;   
       
       
      
      currentBarTime = iTime(_Symbol, _Period, 0);
      
      if (currentBarTime != lastBarTime){
      
      // Resize the array to accommodate the new value
      int newSizeOpen = ArraySize(priceStackOpen) + 1;      
      ArrayResize(priceStackOpen, newSizeOpen);
      int newSizeClose = ArraySize(priceStackClose) + 1;
      ArrayResize(priceStackClose, newSizeClose); 
      
      int newSizeOpenWeekly = ArraySize(weeklyPriceStackOpen) + 1;
      ArrayResize(weeklyPriceStackOpen, newSizeOpenWeekly);
      int newSizeCloseWeekly = ArraySize(weeklyPriceStackClose) + 1;
      ArrayResize(weeklyPriceStackClose, newSizeCloseWeekly);
      
      
      // log candle open prices
      MqlRates lastCandle[];  // Array to store candle data
      MqlRates lastCandleWeekly[];  // Array to store candle data

      // Fetch the last completed candle (index 1)
      if (CopyRates(Symbol(), PERIOD_CURRENT, 1, 1, lastCandle) > 0) {
          double openPrice = lastCandle[0].open;   // Open price of last completed candle
          double closePrice = lastCandle[0].close; // Close price of last completed candle
          
          // Add the value to the last position
          priceStackOpen[newSizeOpen - 1] = openPrice;
          priceStackClose[newSizeClose - 1] = closePrice;
          }
          
      // Fetch the last completed candle (index 1)
      if (CopyRates(Symbol(), PERIOD_W1, 0, 1, lastCandleWeekly) > 0) {
          double weeklyOpen = lastCandleWeekly[0].open;   // Open price of last completed candle
          double weeklyClose = lastCandleWeekly[0].close;  // Close price of last completed candle
          
          // Add the value to the last position
          weeklyPriceStackOpen[newSizeOpenWeekly - 1] = weeklyOpen;
          weeklyPriceStackClose[newSizeCloseWeekly - 1] = weeklyClose;
          }
          
      double wpo = weeklyPriceStackOpen[ArraySize(weeklyPriceStackOpen)-1];
      double wpc = weeklyPriceStackClose[ArraySize(weeklyPriceStackClose)-1];
      bool bullish = wpo < wpc;
      bool bearish = wpo > wpc;
      
      
   
      if (ArraySize(priceStackOpen) > 3){
      //printf("last price: " + priceStack[ArraySize(priceStack)-2]);
      //printf("current price: " + priceStack[ArraySize(priceStack)-1]);
      
      double lpo = priceStackOpen[ArraySize(priceStackOpen)-1];
      double lpc = priceStackClose[ArraySize(priceStackClose)-1];
      
      double lpo2 = priceStackOpen[ArraySize(priceStackOpen)-2];
      double lpc2 = priceStackClose[ArraySize(priceStackClose)-2];
      
      double lpo3 = priceStackOpen[ArraySize(priceStackOpen)-3];
      double lpc3 = priceStackClose[ArraySize(priceStackClose)-3];
      
      
      
      
      if (!tradeDone && tradingBias == "null" && tradeStarted && myMaValue < myMaValue2 && myMaValue < myMaValue3 && myMaValue2 < myMaValue3 && maRange > crossoverRange){
      tradingBias = "sell";
      if(tradePositionCount > 0 && lotSize < 0.1 && crossoverRange > 0){
      lotSize*=1;
      
      }
      
      longPosition = false;
      shortPosition = true;
      }
      
      if (tradeDone && tradingBias == "null" && tradeStarted && myMaValue > myMaValue2 && myMaValue > myMaValue3 && myMaValue2 > myMaValue3 && maRange > crossoverRange){
      tradingBias = "buy";
      if(tradePositionCount > 0 && lotSize < 0.1 && crossoverRange > 0){
      lotSize*=1;
      
      }
      
      shortPosition = false;
      longPosition = true;
      }
      
      double candleMaxSize = 1;
      
      
      
      
      if (tradePositionCount < 1 && tradingBias == "sell" && myMaValue < myMaValue2 && myMaValue < myMaValue3 && myMaValue2 < myMaValue3){
      
      if (lpc < lpo && lpc2 < lpo2 && lpc3 < lpo3){
      tradePositionCount++;
      trade.Sell(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
      tradeActive = true;
      }
      } 
      
      if (tradePositionCount < 1 && tradingBias == "buy" && myMaValue > myMaValue2 && myMaValue > myMaValue3 && myMaValue2 > myMaValue3){
      
      if (lpc > lpo && lpc2 > lpo2 && lpc3 > lpo3){
      tradePositionCount++;
      trade.Buy(lotSize,NULL,Ask,(0),(0),"Bot executed trade");
      tradeActive = true;
      }
      } 
     
      
      if(tradingBias == "buy" && myMaValue < myMaValue2 && myMaValue < myMaValue3 && myMaValue2 < myMaValue3 && maRange > crossoverRange){
      lastPL-=PL;
      for(int i = 0; i < tradePositionCount; i++)
      {
      trade.PositionClose(Symbol()); 
      }
      tradePositionCount = 0;
      tradingBias = "sell";
      }
      
      
      if(tradingBias == "sell" && myMaValue > myMaValue2 && myMaValue > myMaValue3 && myMaValue2 > myMaValue3 && maRange > crossoverRange){
      lastPL-=PL;
      for(int i = 0; i < tradePositionCount; i++)
      {
      trade.PositionClose(Symbol()); 
      }
      tradePositionCount = 0;
      tradingBias = "buy";
      }
      
      
      
            
      }      
      }
     
     
     
 
     
     
     
//locking profit 
debt = MathAbs(lastPL);     
    
     
     // closing trades #3333
     if (tradeComplete && currentPrice > (sellStopPrice + (capturedATRValue * reversalScale)) && currentPrice < (buyStopPrice - (capturedATRValue * reversalScale)))
     {
      analysing = false;
      tradePrimed = false;
      hedgeBuy = false;  
      hedgeSell = false;
      tradingBias = "null";
      for(int i = 0; i < tradePositionCount; i++)
      {
      trade.PositionClose(Symbol()); 
      }
      tradePositionCount = 0;           
      posCount = 1;
      if(!lossComplete){
      lastPL=0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      }
      awaitEntry = 0;
      numIncreaseLots = 0;
      rangeTestCount = 0;
      primedPrice = 1;
      maPrice = -1;
      buyPriceSet = false;
      sellPriceSet = false;
      seekingProfit = false;
      timeInTrade = 0;
      trailingStop = defaultTrailingStop;
      buyPrice = 100000;
      sellPrice = 0;
      tradeAction = "null";
      tradeComplete = false;
      priceDataSet = false;
      tradeStarted = false;
      }
      
      
     


      
        // closing trades #3333
     if (PL > (debt + profitTarget))
     {
      tradeDone = true;
      crossoverRange = 100;
      canTrade = false;
      analysing = true;
      tradePrimed = false;
      hedgeBuy = false;  
      hedgeSell = false;
      for(int i=0 ; i < tradePositionCount; i++){
      trade.PositionClose(Symbol());      
      }
      posCount = 1;
      lastPL=0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = 0;
      numIncreaseLots = 0;
      rangeTestCount = 0;
      primedPrice = 1;
      maPrice = -1;
      buyPriceSet = false;
      sellPriceSet = false;
      seekingProfit = false;
      timeInTrade = 0;
      trailingStop = defaultTrailingStop;
      buyPrice = 100000;
      sellPrice = 0;
      tradeAction = "null";
      maStatus = "null";
      tradeComplete = true;
      priceDataSet = false;
      tradeStarted = false;
      profitTargetShadow = profitTarget;
      }
      
      
      
      
      /*
      //cancelling trades
      if(priceDataSet){
      if(currentPrice > sl_b || currentPrice < sl_s){
      
      tradePrimed = false;
      hedgeBuy = false;  
      hedgeSell = false;
      for(int i=0; i < posCount; i++)
      {
         trade.PositionClose(Symbol());
      }
      posCount = 1;
      lastPL=0;
      lotSize = defaultLotSize;
      debt = 0;
      numSidesTested = 0;
      awaitEntry = freqDelay;
      numIncreaseLots = 0;
      rangeTestCount = 0;
      primedPrice = 1;
      maPrice = -1;
      buyPriceSet = false;
      sellPriceSet = false;
      seekingProfit = false;
      timeInTrade = 0;
      trailingStop = defaultTrailingStop;
      buyPrice = 100000;
      sellPrice = 0;
      tradeAction = "null";
      priceDataSet = false;
      tradeStarted = false;
      }
      }
    */
    



     if(awaitEntry > 0)
     {
      awaitEntry--;
     }
     
     
     if(rangeTestCount > maxRangeTest)
     {
     maxRangeTest = rangeTestCount;
     }
     
     if (PL < maxDrawdown)
     {
     maxDrawdown = PL;
     }
     


  



////////////////////////////////////

//print values to screen
   string myString;
   string myString2;
   string myString3;

// Convert bool to string
   if(buyPriceSet)
     {
      myString = "true";
     }
   else
     {
      myString = "false";
     }

// Convert bool to string
   if(sellPriceSet)
     {
      myString2 = "true";
     }
   else
     {
      myString2 = "false";
     }

// Convert bool to string
   if(tradeStarted)
     {
      myString3 = "true";
     }
   else
     {
      myString3 = "false";
     }





   string text=
      "Balance  | "+DoubleToString(Balance,Digits()+1)+ "\n" +
      "P&L  | "+DoubleToString(PL,Digits()+1) + "\n"+
      "Debt  | "+DoubleToString(debt,Digits()+1) + "\n"+
      "Current  | "+DoubleToString(currentPrice,Digits()+1) + "\n"+
      "Buy price  | "+DoubleToString(buyPrice,Digits()+1) + "\n"+
      "Sell price  | "+DoubleToString(sellPrice,Digits()+1) + "\n"+
      "Wait  | "+DoubleToString(awaitEntry,Digits()+1) + "\n"+
      "Max chain  | "+DoubleToString(maxRangeTest,Digits()+1) + "\n"+
      "Max drawdown  | "+DoubleToString(maxDrawdown,Digits()+1) + "\n"+
      "Min Lots  | "+DoubleToString(defaultLotSize,Digits()+1) + "\n"+
      "Consolidation limit  | "+DoubleToString(consolidationLimit,Digits()+1) + "\n"+
      "ATR  | "+DoubleToString(myAtrValue,Digits()+1) + "\n"+
      "Buy price set | "+ myString + "\n"+
      "Sell price set | "+ myString2 + "\n"+
      "In trade | "+ myString3 + "\n"+
      "Price range  | "+DoubleToString(priceRange,Digits()+1) + "\n"+
      "Num sidesTested | "+IntegerToString(numSidesTested)+ "\n" +
      "price deviation | "+DoubleToString(priceDeviation)+ "\n" +
      "Ma range| "+DoubleToString(maRange);
      
      

   Comment(text);
   
   

}
  
//+------------------------------------------------------------------+MT5|Expert!40
