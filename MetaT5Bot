// MetaT5Bot //////////////////////////////////
// US30/ Dow Jones Trade Bot                // 
/////////////////////////////////////////////

// This robot is still under heavy development and may not produce the results you expect. 


// creatre an instance of ctrade
#include <Trade\trade.mqh>
CTrade trade;

bool userAlerted;
string Action;
int tickTradeDuration;
bool tradeStarted;
double lotSize;
int awaitEntry;
int waitTime;
int entryThreshold;
int tradeLevel;
int waitTradeTime;
int numOfTradesOpen;
bool inTradeBuy;
bool inTradeSell;
bool inTrade2;
int checkCycle;
bool counterTrade;
double maxAllowedDist;
double lastBalance;
MqlRates PriceInfo[];
double spanAverage;
double spanLow;
double spanHigh;
double maxRiskAmt;
double coolDownPeriod;
double trendingDuration;
bool isHedgeTradeSell;
bool isHedgeTradeBuy;
double spanWidth;
double acceptedSpanWidth;
string tradeStatus;
double takeProfit;
double stopLoss;
double maxTrendingDuration;
double tradingFrequency;
double lotSizeHedging;

double myTenkanSenValue;

bool p1Set;
bool p2Set;
bool p3Set;
double p1;
double p2;
double p3;
double pStep;
string tradeBias;
bool biasSellSet;
bool biasBuySet;
/*
void OpenBuyOrder()
   {
   
   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
   
   MqlTradeRequest myrequest;
   MqlTradeResult myresult;
   ZeroMemory(myrequest);
   
   
   myrequest.action=TRADE_ACTION_DEAL;
   myrequest.type=ORDER_TYPE_BUY;
   myrequest.symbol=_Symbol;
   myrequest.volume=0.03;
   myrequest.type_filling=ORDER_FILLING_FOK;
   myrequest.price=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   myrequest.tp=309;
   myrequest.sl=0;
   myrequest.deviation=50;
   OrderSend(myrequest,myresult);
      
   
   }
*/






int OnInit()
  {
  userAlerted = false;
  Action = "";
  tickTradeDuration = 0;
  tradeStarted = false;

 
  awaitEntry = 0;
  waitTime = 1;
  entryThreshold = 20;
  tradeLevel = 0;
  waitTradeTime = 0;
  numOfTradesOpen = 0;
  inTradeBuy = false;
  inTradeSell = false;
  inTrade2 = false;  
  spanAverage = 0;
  spanLow = 0;
  spanHigh = 0;
  checkCycle = 0;
  counterTrade = false;
  lotSizeHedging = 0.01;
  lastBalance = 0;
  maxRiskAmt = 300;
  
  trendingDuration = 0;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  spanWidth = 0;
  tradeStatus = "null";
  p1Set = false;
  p2Set = false; 
  p3Set = false;
  p1 = 0;
  p2 = 0;
  p3 = 0;
  pStep = 0;
  
  
  maxAllowedDist = 40;
  acceptedSpanWidth = 3;
  tradingFrequency = 2000;
  coolDownPeriod = tradingFrequency;  
  lotSize = 0.01;
  takeProfit = 30;
  stopLoss = 0;
  maxTrendingDuration = 100;
  tradeBias = "null";
  biasSellSet = false;
  biasBuySet = false;
  
  
  
  return(INIT_SUCCEEDED);
  
  }

 void CreatePriceReport()
{
 pStep = pStep + 1;
 
 if(pStep == 1)
 {
 trade.PositionClose(Symbol());
 p1 = myTenkanSenValue;
 }
 if(pStep == 2)
 {
 p2 = myTenkanSenValue;
 }
 if(pStep == 3)
 {
 p3 = myTenkanSenValue;
 }
}


void OnTick()
  {
  
  
  double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
  double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
  double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
  double PL = (Equity - Balance);  
  
  
  // we calculate the ask price 
  //double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK,_Digits);
  
  // we calculate the bid price
  //double Bid=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID,_Digits);
  
  
  // create array for the price data
  double myRSIArray[];
  double myCCIArray[];
  double mySpanAArray[];
  double mySpanBArray[];
  double myTenkanSenArray[];
  
  
  
  // Sort it from current candle to oldest candle 
  ArraySetAsSeries(PriceInfo, true);
   
  
  
  int myRSIDefinition=iRSI(_Symbol, _Period,14,PRICE_CLOSE);
  int myCCIDefinition=iCCI(_Symbol, _Period,14,PRICE_CLOSE);
  int myIchimokuDefinition=iIchimoku(_Symbol, _Period,9,26,52);
  
  
  
  // sort the price data from the current candle downwards 
  ArraySetAsSeries(myRSIArray,true);
  ArraySetAsSeries(myCCIArray,true);
  ArraySetAsSeries(mySpanAArray,true);
  ArraySetAsSeries(mySpanBArray,true);
  ArraySetAsSeries(myTenkanSenArray,true);
  
  
  
  // defined ea, from current candle, for 3 candles, save in array
  CopyBuffer(myRSIDefinition,0,0,3,myRSIArray);
  CopyBuffer(myCCIDefinition,0,0,3,myCCIArray);
  CopyBuffer(myIchimokuDefinition,2,0,3,mySpanAArray);
  CopyBuffer(myIchimokuDefinition,3,0,3,mySpanBArray);
  CopyBuffer(myIchimokuDefinition,0,0,3,myTenkanSenArray);
  
  
  // calculate the current rsi & cci values
  double myRSIValue=NormalizeDouble(myRSIArray[0],2);
  double myCCIValue=NormalizeDouble(myCCIArray[0],2);
  double mySpanAValue=mySpanAArray[0];
  double mySpanBValue=mySpanBArray[0];
  myTenkanSenValue=myTenkanSenArray[0];
  
  
 
  
  
  
 

  spanAverage = MathAbs((mySpanAValue + mySpanBValue) / 2);  
  spanHigh = spanAverage + maxAllowedDist;
  spanLow = spanAverage - maxAllowedDist;
  spanWidth = MathAbs(mySpanAValue - mySpanBValue);
  
  
  // logic for alerting the user of a potential trade setup
  
 
  
  /*
  if (!userAlerted && myRSIValue > 69 && myCCIValue > 99 || !userAlerted && myRSIValue < 31 && myCCIValue < -99)
  {
  PlaySound("alert.wav");
  userAlerted = true;
  }
  */
  
  // set overal price bias to gauge price the level
  
  if(myTenkanSenValue > spanLow && !biasSellSet)
  {
  trade.PositionClose(Symbol());
  biasSellSet = true;
  biasBuySet = false;
  }
  
  if(myTenkanSenValue < spanHigh && !biasBuySet)
  {
  trade.PositionClose(Symbol());
  biasBuySet = true;
  biasSellSet = false;
  }   

  
  
  // oversold conditions where sentiment is to buy up
  //if (myRSIValue < 31 && myCCIValue < -100)
  if (myRSIValue < 31 && myCCIValue < -100)
  {
  //PlaySound("alert.wav");
  if(spanWidth > acceptedSpanWidth && myTenkanSenValue < spanLow)
  {
  tradeStarted = true;
  
  
  
  // conditions for oversold
  
  if (awaitEntry < waitTime)
  {
  CreatePriceReport();
  if(pStep > 3)
  {
  if(p3 > p1)
  {
  trade.Sell(lotSize,NULL,Ask,(0),(0),NULL);
  tradeStatus = "sell";
  }
  else
  {  
  trade.Buy(lotSize,NULL,Ask,(0),(0),NULL);
  tradeStatus = "buy";
  }
  }
  
  //trade.Sell(lotSize,NULL,Ask,(0),(Ask-takeProfit * _Point),NULL);
  //trade.Buy(lotSize,NULL,Ask,(0),(Ask+takeProfit * _Point),NULL);
  inTradeBuy = true;
  inTrade2 = true;
  numOfTradesOpen = numOfTradesOpen + 1;
  awaitEntry = 0;
  }
  }
  }    
  
  
  
    
  // overbought conditions where sentiment is to sell down
  // if (myRSIValue > 70 && myCCIValue > 100)
  if (myRSIValue > 70 && myCCIValue > 100)
  {
  //PlaySound("alert.wav");
  if(spanWidth > acceptedSpanWidth && myTenkanSenValue > spanHigh)
  {
  tradeStarted = true;
  
  
  
  // conditions for overbought
  
  if (awaitEntry < waitTime)
  {
  CreatePriceReport();
  if(pStep > 3)
  {
  if(p3 > p1)
  {
  trade.Sell(lotSize,NULL,Ask,(0),(0),NULL);
  tradeStatus = "sell";
  }
  else
  {  
  trade.Buy(lotSize,NULL,Ask,(0),(0),NULL);
  tradeStatus = "buy";
  }
  }
 

  //trade.Buy(lotSize,NULL,Ask,(0),(Ask+takeProfit * _Point),NULL);
  //trade.Sell(lotSize,NULL,Ask,(0),(Ask-takeProfit * _Point),NULL);
  inTradeSell = true;
  inTrade2 = true;
  numOfTradesOpen = numOfTradesOpen + 1;
  awaitEntry = 0;
  } 
  } 
  }
  
  
  
 
  
   
  
 
  
  
   
  
  
  
  
  
  
  // trade tick based events  
  
  if(tradeStarted)
  {
   awaitEntry = awaitEntry + 1;
  }
  
  if(inTradeBuy || inTradeSell)
  {
  waitTradeTime = waitTradeTime + 1;
  }
  
  if(numOfTradesOpen == 0)
  {
  waitTradeTime = 0;
  }
  
  
  
  if(awaitEntry > (coolDownPeriod))
  {
  awaitEntry = 0;
  tradeStarted = false;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  
  
  
  
  
  if(Balance > lastBalance)
  {
  lastBalance = Balance;
  }  
  }
  
  
  if(PL > takeProfit)
  {
  
  tradeStarted = false;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  inTradeBuy = false;
  inTradeSell = false;
  trade.PositionClose(Symbol());
  p1 = 0;
  p2 = 0;
  p3 = 0;
  pStep = 0;
  
  }
  
  /*
  if (tradeStatus == "buy" && myTenkanSenValue > spanHigh)
  {
  tradeStarted = false;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  inTradeBuy = false;
  inTradeSell = false;
  trade.PositionClose(Symbol());
  p1 = 0;
  p2 = 0;
  p3 = 0;
  pStep = 0;
  trade.Buy(0.01,NULL,Ask,(0),(0),NULL);
  trade.Buy(0.01,NULL,Ask,(0),(0),NULL);
  trade.Buy(0.01,NULL,Ask,(0),(0),NULL);
  trade.Buy(0.01,NULL,Ask,(0),(0),NULL);
  tradeStatus = "null";
  
    
  }
  
  if (tradeStatus == "sell" && myTenkanSenValue < spanLow)
  {
  tradeStarted = false;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  inTradeBuy = false;
  inTradeSell = false;
  trade.PositionClose(Symbol());
  p1 = 0;
  p2 = 0;
  p3 = 0;
  pStep = 0;
  trade.Sell(0.01,NULL,Ask,(0),(0),NULL);
  trade.Sell(0.01,NULL,Ask,(0),(0),NULL);
  trade.Sell(0.01,NULL,Ask,(0),(0),NULL);
  trade.Sell(0.01,NULL,Ask,(0),(0),NULL);
  tradeStatus = "null";
 
  }
  */
  
  
  if(myRSIValue > 70 || myRSIValue < 30)
  {
  trendingDuration = trendingDuration + 1;
  }
  else
  {
  trendingDuration = 0;
  
  }
  
  if(myRSIValue > 70)
  {
  isHedgeTradeSell = false;
  }
  
  if(myRSIValue < 30)
  {
  isHedgeTradeBuy = false;
  }
  

  
  
 //print values to screen  
 Comment("CCI: ", myCCIValue , "\n", "RSI: ", myRSIValue, "\n", "Balance: " , Balance, "\n", Equity, "\n", "Entry wait time: ", 
 awaitEntry, "\n", "P&L: ", PL, "\n", "Action: ", Action, "\n", "Trending duration: ", trendingDuration,
 "\n", "Span width", spanWidth, "\n", "Hedging down: ", isHedgeTradeSell, "\n", "Hedging up: ", isHedgeTradeBuy,
 "\n", "Trade status: ", tradeStatus, "\n", "Trade started: ", tradeStarted, "\n", "p1: ", p1, "\n", "p2: ", p2, 
 "\n", "p3: ", p3);
  
  
 }
