// creatre an instance of ctrade
#include <Trade\trade.mqh>
CTrade trade;

bool userAlerted;
string Action;
int tickTradeDuration;
bool tradeStarted;
double lotSize;
int awaitEntry;
int waitTime;
int entryThreshold;
int tradeLevel;
int waitTradeTime;
int numOfTradesOpen;
bool inTrade;
bool inTrade2;
int checkCycle;
bool counterTrade;
double maxAllowedDist;
double lastBalance;
MqlRates PriceInfo[];
double spanAverage;
double spanLow;
double spanHigh;
double maxRiskAmt;
double coolDownPeriod;
double trendingDuration;
bool isHedgeTradeSell;
bool isHedgeTradeBuy;
double spanWidth;
double acceptedSpanWidth;
string tradeStatus;
double defaultCoolDownTime;
double takeProfit;
double stopLoss;
double maxTrendingDuration;

/*
void OpenBuyOrder()
   {
   
   double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
   double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
   double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
   
   MqlTradeRequest myrequest;
   MqlTradeResult myresult;
   ZeroMemory(myrequest);
   
   
   myrequest.action=TRADE_ACTION_DEAL;
   myrequest.type=ORDER_TYPE_BUY;
   myrequest.symbol=_Symbol;
   myrequest.volume=0.03;
   myrequest.type_filling=ORDER_FILLING_FOK;
   myrequest.price=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   myrequest.tp=309;
   myrequest.sl=0;
   myrequest.deviation=50;
   OrderSend(myrequest,myresult);
      
   
   }
*/





int OnInit()
  {
  userAlerted = false;
  Action = "";
  tickTradeDuration = 0;
  tradeStarted = false;

 
  awaitEntry = 0;
  waitTime = 1;
  entryThreshold = 20;
  tradeLevel = 0;
  waitTradeTime = 0;
  numOfTradesOpen = 0;
  inTrade = false;
  inTrade2 = false;  
  spanAverage = 0;
  spanLow = 0;
  spanHigh = 0;
  checkCycle = 0;
  counterTrade = false;
  maxAllowedDist = 15;
  lotSize = 0.01;
  lastBalance = 0;
  maxRiskAmt = 300;
  defaultCoolDownTime = 300;
  coolDownPeriod = defaultCoolDownTime;
  trendingDuration = 0;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  spanWidth = 0;
  acceptedSpanWidth = 80;
  tradeStatus = "null";
  takeProfit = 1;
  stopLoss = 50;
  maxTrendingDuration = 2000;
  
  
  return(INIT_SUCCEEDED);
  
  }




void OnTick()
  {
  
  
  double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);
  double Equity=AccountInfoDouble(ACCOUNT_EQUITY);
  double Balance=AccountInfoDouble(ACCOUNT_BALANCE);
  double PL = (Equity - Balance);  
  
  
  // we calculate the ask price 
  //double Ask=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK,_Digits);
  
  // we calculate the bid price
  //double Bid=NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID,_Digits);
  
  
  // create array for the price data
  double myRSIArray[];
  double myCCIArray[];
  double mySpanAArray[];
  double mySpanBArray[];
  double myTenkanSenArray[];
  
  
  // Sort it from current candle to oldest candle 
  ArraySetAsSeries(PriceInfo, true);
   
  
  
  int myRSIDefinition=iRSI(_Symbol, _Period,14,PRICE_CLOSE);
  int myCCIDefinition=iCCI(_Symbol, _Period,14,PRICE_CLOSE);
  int myIchimokuDefinition=iIchimoku(_Symbol, _Period,9,26,52);
  
  
  
  // sort the price data from the current candle downwards 
  ArraySetAsSeries(myRSIArray,true);
  ArraySetAsSeries(myCCIArray,true);
  ArraySetAsSeries(mySpanAArray,true);
  ArraySetAsSeries(mySpanBArray,true);
  ArraySetAsSeries(myTenkanSenArray,true);
  
  
  
  // defined ea, from current candle, for 3 candles, save in array
  CopyBuffer(myRSIDefinition,0,0,3,myRSIArray);
  CopyBuffer(myCCIDefinition,0,0,3,myCCIArray);
  CopyBuffer(myIchimokuDefinition,2,0,3,mySpanAArray);
  CopyBuffer(myIchimokuDefinition,3,0,3,mySpanBArray);
  CopyBuffer(myIchimokuDefinition,0,0,3,myTenkanSenArray);
  
  
  // calculate the current rsi & cci values
  double myRSIValue=NormalizeDouble(myRSIArray[0],2);
  double myCCIValue=NormalizeDouble(myCCIArray[0],2);
  double mySpanAValue=mySpanAArray[0];
  double mySpanBValue=mySpanBArray[0];
  double myTenkanSenValue=myTenkanSenArray[0];
 

  spanAverage = MathAbs((mySpanAValue + mySpanBValue) / 2);  
  spanHigh = spanAverage + 40;
  spanLow = spanAverage - 40;
  spanWidth = MathAbs(mySpanAValue - mySpanBValue);
  
  
  // logic for alerting the user of a potential trade setup
  
 
  
  /*
  if (!userAlerted && myRSIValue > 69 && myCCIValue > 99 || !userAlerted && myRSIValue < 31 && myCCIValue < -99)
  {
  PlaySound("alert.wav");
  userAlerted = true;
  }
  */
  

  
  
  // oversold conditions where sentiment is to buy up
  if (myRSIValue < 31 && myCCIValue < -99)
  {
  //PlaySound("alert.wav");
  if(spanWidth > acceptedSpanWidth && myTenkanSenValue < spanLow)
  {
  tradeStarted = true;
  
  
  // conditions for oversold
  
  if (awaitEntry < waitTime && trendingDuration < maxTrendingDuration)
  {
  trade.Buy(lotSize,NULL,Ask,(0),(0),NULL);
  //trade.Sell(0.01,NULL,Ask,(0),(Ask-1000 * _Point),NULL);
  inTrade = true;
  inTrade2 = true;
  numOfTradesOpen = numOfTradesOpen + 1;
  awaitEntry = 0;
  Action = "buy";
  }
  if(awaitEntry < waitTime && trendingDuration > maxTrendingDuration)
  {
  if (isHedgeTradeSell == false)
  {
  if( myTenkanSenValue < spanLow)
  {
  trade.Sell(lotSize,NULL,Ask,(0),(0),NULL);
  }
  isHedgeTradeSell = true;
  }
  }  
  }
  }    
  
  
  
    
  // overbought conditions where sentiment is to sell down
  if (myRSIValue > 69 && myCCIValue > 99)
  {
  //PlaySound("alert.wav");
  if(spanWidth > acceptedSpanWidth && myTenkanSenValue > spanHigh)
  {
  tradeStarted = true;
  
  
  // conditions for overbought
  
  if (awaitEntry < waitTime && trendingDuration < maxTrendingDuration)
  {
  trade.Sell(lotSize,NULL,Ask,(0),(0),NULL);
  //trade.Sell(0.01,NULL,Ask,(0),(Ask-1000 * _Point),NULL);
  inTrade = true;
  inTrade2 = true;
  numOfTradesOpen = numOfTradesOpen + 1;
  awaitEntry = 0;
  Action = "sell";
  }
  if(awaitEntry < waitTime && trendingDuration > maxTrendingDuration)
  {
  if (isHedgeTradeBuy == false)
  {
  if( myTenkanSenValue > spanHigh)
  {
  trade.Buy(lotSize,NULL,Ask,(0),(0),NULL);
  }
  isHedgeTradeBuy = true;
  }
  }  
  } 
  }
  
  
  // OB OS conditions
  
  
  
 
  
   
  
 
  
  
   
  
  
  
  
  
  
  // trade tick based events  
  
  if(tradeStarted)
  {
   awaitEntry = awaitEntry + 1;
  }
  
  if(inTrade)
  {
  waitTradeTime = waitTradeTime + 1;
  }
  
  if(numOfTradesOpen == 0)
  {
  waitTradeTime = 0;
  }
  
  
  
  if(awaitEntry > (coolDownPeriod))
  {
  awaitEntry = 0;
  tradeStarted = false;
  inTrade = false;
  
  if(Balance > lastBalance)
  {
  lastBalance = Balance;
  }  
  }
  
  
  if(PL > takeProfit)
  {
  coolDownPeriod = defaultCoolDownTime;
  isHedgeTradeSell = false;
  isHedgeTradeBuy = false;
  if(numOfTradesOpen!=0)
  {
  numOfTradesOpen = numOfTradesOpen - 1;
  }  
  trade.PositionClose(Symbol());
  } 
  
  
  
  if(PL < -stopLoss)
  {
  
  if(awaitEntry < waitTime && trendingDuration > 2000)
  {
  if (isHedgeTradeSell == false)
  {
  if( myTenkanSenValue < spanLow)
  {
  trade.Sell(0.05,NULL,Ask,(0),(0),NULL);
  }
  isHedgeTradeSell = true;
  }
  }  
  
  
  if(awaitEntry < waitTime && trendingDuration > 2000)
  {
  if (isHedgeTradeBuy == false)
  {
  if( myTenkanSenValue > spanHigh)
  {
  trade.Buy(0.05,NULL,Ask,(0),(0),NULL);
  }
  isHedgeTradeBuy = true;
  }
  }  
   
  
  
  
  }
 
  
  
  
  
  if(myRSIValue > 69 || myRSIValue < 31)
  {
  trendingDuration = trendingDuration + 1;
  }
  else
  {
  trendingDuration = 0;
  
  }
  
  if(myRSIValue > 70)
  {
  isHedgeTradeSell = false;
  }
  
  if(myRSIValue < 30)
  {
  isHedgeTradeBuy = false;
  }
  
  
  
  if(trendingDuration  > 4000)
  {
  coolDownPeriod = 20000;
  waitTime = 1;
  //trade.PositionClose(Symbol());
  }
  

  
  
 //print values to screen  
 Comment(myCCIValue , "\n", myRSIValue, "\n", Balance, "\n", Equity, "\n", "Entry wait time: ", 
 awaitEntry, "\n", "P&L: ", PL, "\n", "Action: ", Action, "\n", "Trending duration: ", trendingDuration,
 "\n", "Span width", spanWidth, "\n", "Hedging down: ", isHedgeTradeSell, "\n", "Hedging up: ", isHedgeTradeBuy,
 "\n", "Trade status: ", tradeStatus, "Trade started: ", tradeStarted);
  
  
 }
